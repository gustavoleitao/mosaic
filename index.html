<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mosaico de Cubos</title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
        }

        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 1;
        }

        #showHide {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1;
        }

        #blockTable {
            margin-top: 20px;
            /* Adicionar espaço entre o conteúdo anterior e a tabela */
            clear: both;
            /* Garantir que a tabela fique abaixo de qualquer conteúdo flutuante */
        }

        #generateTable {
            margin-top: 5px;
            display: block;
        }

        /* O modal (fica escondido por padrão) */
        .modal {
            display: none;
            /* Escondido por padrão */
            position: fixed;
            /* Fica fixo na tela */
            z-index: 1;
            /* Fica sobre o conteúdo */
            left: 0;
            top: 0;
            width: 100%;
            /* Largura total */
            height: 100%;
            /* Altura total */
            background-color: rgba(0, 0, 0, 0.5);
            /* Fundo preto transparente */
        }

        /* Conteúdo do modal */
        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            /* Centralizado verticalmente */
            padding: 20px;
            border: 1px solid #888;
            width: 100%;
            /* Largura do modal */
        }

        /* Botão de fechar */
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }

        .close:hover,
        .close:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div id="controls">
        <form id="cubeForm">
            <label for="rows">Linhas:</label>
            <input type="number" id="rows" name="rows" value="10" min="1"><br><br>

            <label for="cols">Colunas:</label>
            <input type="number" id="cols" name="cols" value="30" min="1"><br><br>

            <label>Selecione as Alturas:</label><br>
            <input type="checkbox" id="height1" name="heights" value="0.5" checked>
            <label for="height1">0.5</label><br>
            <input type="checkbox" id="height2" name="heights" value="1" checked>
            <label for="height2">1</label><br>
            <input type="checkbox" id="height7" name="heights" value="1.5">
            <label for="height7">1.5</label><br>
            <input type="checkbox" id="height3" name="heights" value="2">
            <label for="height3">2</label><br>
            <input type="checkbox" id="height8" name="heights" value="2.5">
            <label for="height8">2.5</label><br>
            <input type="checkbox" id="height4" name="heights" value="3">
            <label for="height4">3</label><br>
            <input type="checkbox" id="height5" name="heights" value="4">
            <label for="height5">4</label><br>
            <input type="checkbox" id="height6" name="heights" value="5">
            <label for="height6">5</label><br><br>

            <label>Selecione as Texturas:</label><br>
            <input type="checkbox" id="texture1" name="textures"
                value="https://cdn.architextures.org/textures/20/11/oak-5fc4cb29cb8cc-1200.jpg" checked>
            <label for="texture1">Madeira de Carvalho</label><br>
            <input type="checkbox" id="texture2" name="textures"
                value="https://cdn.architextures.org/textures/20/11/ash-5fc4cb2f0d6d2-1200.jpg">
            <label for="texture2">Madeira de Freixo</label><br>
            <input type="checkbox" id="texture3" name="textures"
                value="https://cdn.architextures.org/textures/20/11/charred-timber-5fc4cb0884792-1200.jpg">
            <label for="texture3">Madeira Queimada</label><br>
            <input type="checkbox" id="texture4" name="textures"
                value="https://cdn.architextures.org/textures/20/11/dark-stained-timber-5fc4cb107f98c-1200.jpg">
            <label for="texture4">Dark Stained Timber</label><br><br>
            

            <label for="useSubpattern">Usar Subpadrão:</label>
            <input type="checkbox" id="useSubpattern" name="useSubpattern"><br><br>

            <label for="subpatternSize">Tamanho do Subpadrão:</label>
            <input type="number" id="subpatternSize" name="subpatternSize" value="2" min="1" disabled><br><br>

            <button type="submit">Gerar Mosaico</button>

        </form>


        <button id="exportMap">Exportar Mapa (JSON)</button><br><br>
        <input type="file" id="importMap" accept=".json">


    </div>
    <div id="showHide">
        <button id="togglePanel">Esconder Controles</button>
        <button id="generateTable">Gerar Tabela de Cubos</button>
    </div>




    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>

        const controlPanel = document.getElementById('controls');
        const toggleButton = document.getElementById('togglePanel');

        toggleButton.addEventListener('click', function () {
            if (controlPanel.style.display === 'none') {
                controlPanel.style.display = 'block';
                toggleButton.textContent = 'Esconder Controles';
            } else {
                controlPanel.style.display = 'none';
                toggleButton.textContent = 'Mostrar Controles';
            }
        });

        const cache = {};
        let currentMosaic = [];

        let materialIds = {}; // Armazena os IDs sequenciais de cada tipo de material
        let materialIdCounter = 1; // Inicializa o contador para os IDs

        let blockCount = {};  // Armazena a quantidade de cada tipo de cubo

        const textureNames = {
            'https://cdn.architextures.org/textures/20/11/oak-5fc4cb29cb8cc-1200.jpg': 'Madeira de Carvalho',
            'https://cdn.architextures.org/textures/20/11/ash-5fc4cb2f0d6d2-1200.jpg': 'Madeira de Freixo',
            'https://cdn.architextures.org/textures/20/11/charred-timber-5fc4cb0884792-1200.jpg': 'Madeira Queimada',
            'https://cdn.architextures.org/textures/20/11/dark-stained-timber-5fc4cb107f98c-1200.jpg': 'Dark Stained Timber'            
        };

        function countBlock(height, texture) {
            const textureName = textureNames[texture] || 'Desconhecido';
            const key = `Altura: ${height}, Textura: ${textureName}`;

            // Verifica se o tipo de material já tem um ID; caso contrário, atribui um novo ID sequencial
            if (!materialIds[key]) {
                materialIds[key] = materialIdCounter++;
            }

            // Conta o número de blocos de cada tipo
            if (blockCount[key]) {
                blockCount[key]++;
            } else {
                blockCount[key] = 1;
            }
        }
        // Função para criar cubo com textura
        function cube(width = 1, height = 1, depth = 1, texture) {
            return textureCube(width, height, depth, texture);
        }

        // Função para criar cubo com material
        function materialCube(width = 1, height = 1, depth = 1, material) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const cube = new THREE.Mesh(geometry, material);
            return cube;
        }

        // Função para pegar textura em cache ou carregar
        function getTexture(path) {
            if (cache[path]) {
                return cache[path];
            } else {
                const textureLoader = new THREE.TextureLoader();
                const woodTexture = textureLoader.load(path);
                cache[path] = woodTexture;
                return woodTexture;
            }
        }

        // Função para criar cubo com textura
        function textureCube(width = 1, height = 1, depth = 1, path) {
            const material = new THREE.MeshBasicMaterial({ map: getTexture(path) });
            return materialCube(width, height, depth, material);
        }

        // Função auxiliar para selecionar valor aleatório de uma lista
        function randomFromValues(values) {
            const randomIndex = Math.floor(Math.random() * values.length);
            return values[randomIndex];
        }

        // Função para criar cubo de madeira com altura e textura definidas
        function createWoodCube(width, depth, height, texture, row, col) {
            const myCube = cube(width, height, depth, texture);

            // Posicionar o cubo de modo que sua base fique em Y=0 (plano de base)
            myCube.position.y = height / 2;  // Ajusta para que a base do cubo fique alinhada no eixo Y

            currentMosaic.push({ row, col, height, texture }); // Salva o cubo no mapa
            countBlock(height, texture);  // Conta o bloco
            return myCube;
        }

        // Função para gerar a tabela de materiais
        function generateBlockTable() {
            const blockTableDiv = document.getElementById('blockTable');
            blockTableDiv.innerHTML = ''; // Limpar o conteúdo anterior

            if (Object.keys(blockCount).length === 0) {
                blockTableDiv.innerHTML = '<p>Nenhum cubo foi gerado ainda.</p>';
                return;
            }

            // Criar a tabela de materiais
            let table = '<table border="1"><tr><th>ID</th><th>Altura</th><th>Madeira</th><th>Quantidade</th></tr>';

            // Adicionar linhas para cada tipo de cubo
            for (const key in blockCount) {
                const [altura, textura] = key.split(', ');
                const materialId = materialIds[key]; // Pega o ID do material
                table += `<tr><td>${materialId}</td><td>${altura.split(': ')[1]}</td><td>${textura.split(': ')[1]}</td><td>${blockCount[key]}</td></tr>`;
            }

            table += '</table>';

            // Exibir a tabela de materiais no div
            blockTableDiv.innerHTML = table;
        }

        // Função para gerar a tabela do mosaico
        function generateMosaicTable(rows, cols) {
            const mosaicTableDiv = document.getElementById('mosaicTable');
            mosaicTableDiv.innerHTML = ''; // Limpar o conteúdo anterior

            if (currentMosaic.length === 0) {
                mosaicTableDiv.innerHTML = '<p>Nenhum mosaico foi gerado ainda.</p>';
                return;
            }

            // Criar a tabela do mosaico
            let table = '<table border="1">';

            // Percorrer as linhas e colunas do mosaico
            for (let i = 0; i < rows; i++) {
                table += '<tr>';
                for (let j = 0; j < cols; j++) {
                    const { height, texture } = currentMosaic.find(cube => cube.row === i && cube.col === j);
                    const textureName = textureNames[texture] || 'Desconhecido';
                    const key = `Altura: ${height}, Textura: ${textureName}`;
                    const materialId = materialIds[key]; // Pega o ID do material para essa célula
                    table += `<td>${materialId}</td>`;
                }
                table += '</tr>';
            }

            table += '</table>';

            // Exibir a tabela do mosaico no div
            mosaicTableDiv.innerHTML = table;
        }

        // Configuração da cena e câmera
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xDDDDDD);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Função para criar subpadrão
        function createSubpattern(subpatternSize, heights, textures) {
            const subpattern = [];
            for (let i = 0; i < subpatternSize; i++) {
                const row = [];
                for (let j = 0; j < subpatternSize; j++) {
                    const height = randomFromValues(heights);
                    const texture = randomFromValues(textures);
                    row.push({ height, texture });
                }
                subpattern.push(row);
            }
            return subpattern;
        }

        // Função para criar a malha de cubos com base nas entradas do usuário
        function createMosaic(rows, cols, heights, textures, useSubpattern = false, subpatternSize = 2) {
            blockCount = {}; // Limpar a contagem de blocos
            currentMosaic = []; // Limpar o mapa atual

            // Remover todos os cubos antigos da cena
            while (scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }

            const cubeWidth = 1;
            const cubeDepth = 1;
            const gap = 0.01;  // Distância entre os cubos

            let subpattern;
            if (useSubpattern) {
                subpattern = createSubpattern(subpatternSize, heights, textures); // Cria o subpadrão
            }

            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    let cube;

                    if (useSubpattern) {
                        // Obter o subpadrão baseado nas coordenadas atuais
                        const subRow = i % subpatternSize;
                        const subCol = j % subpatternSize;
                        const { height, texture } = subpattern[subRow][subCol];

                        cube = createWoodCube(cubeWidth, cubeDepth, height, texture, i, j);
                    } else {
                        const height = randomFromValues(heights);
                        const texture = randomFromValues(textures);
                        cube = createWoodCube(cubeWidth, cubeDepth, height, texture, i, j);
                    }

                    const xPosition = j * (cubeWidth + gap);
                    const zPosition = i * (cubeDepth + gap);
                    cube.position.set(xPosition, cube.position.y, zPosition);
                    scene.add(cube);
                }
            }

            // Calcula o centro do mosaico
            const centerX = (cols * (cubeWidth + gap)) / 2;
            const centerZ = (rows * (cubeDepth + gap)) / 2;

            // Ajusta o ponto de rotação da câmera para o centro do mosaico
            controls.target.set(centerX - (cubeWidth + gap) / 2, 0, centerZ - (cubeDepth + gap) / 2);
            controls.update();

            // Calcula a maior dimensão entre linhas e colunas
            const maxDimension = Math.max(rows, cols);

            // Ajusta a posição da câmera para visualizar todo o mosaico
            const distanceFactor = .5; // Fator para ajustar a distância da câmera
            camera.position.set(centerX, maxDimension * distanceFactor, centerZ + maxDimension * distanceFactor);
            camera.lookAt(centerX, 0, centerZ);

        }

        // Função de renderização
        function render() {
            controls.update();
            renderer.render(scene, camera);
        }

        // Chamando a função de renderização continuamente
        renderer.setAnimationLoop(render);

        // Ajustar o tamanho do canvas ao redimensionar a janela
        window.addEventListener('resize', () => {
            const width = window.innerWidth;
            const height = window.innerHeight;
            renderer.setSize(width, height);
            camera.aspect = width / height;
            camera.updateProjectionMatrix();
        });

        // Habilitar ou desabilitar o campo de tamanho do subpadrão
        document.getElementById('useSubpattern').addEventListener('change', function () {
            const subpatternSizeInput = document.getElementById('subpatternSize');
            subpatternSizeInput.disabled = !this.checked;
        });

        // Função para processar o formulário
        document.getElementById('cubeForm').addEventListener('submit', function (event) {
            event.preventDefault();  // Impedir o envio padrão do formulário

            // Capturar os valores do formulário
            const rows = parseInt(document.getElementById('rows').value);
            const cols = parseInt(document.getElementById('cols').value);

            // Capturar as alturas selecionadas (checkboxes)
            const selectedHeights = Array.from(document.querySelectorAll('input[name="heights"]:checked'))
                .map(input => parseFloat(input.value));

            if (selectedHeights.length === 0) {
                alert("Por favor, selecione ao menos uma altura.");
                return;
            }

            // Capturar as texturas selecionadas (checkboxes)
            const selectedTextures = Array.from(document.querySelectorAll('input[name="textures"]:checked'))
                .map(input => input.value);

            if (selectedTextures.length === 0) {
                alert("Por favor, selecione ao menos uma textura.");
                return;
            }

            // Verificar se o subpadrão foi selecionado
            const useSubpattern = document.getElementById('useSubpattern').checked;
            let subpatternSize = parseInt(document.getElementById('subpatternSize').value);

            if (isNaN(subpatternSize) || subpatternSize < 1) {
                subpatternSize = 2; // Valor padrão caso seja inválido
            }

            // Criar o mosaico de cubos com os valores inseridos
            createMosaic(rows, cols, selectedHeights, selectedTextures, useSubpattern, subpatternSize);



        });

        // Gera a cena inicial ao carregar
        createMosaic(10, 30, [0.5, 1], [
            'https://cdn.architextures.org/textures/20/11/oak-5fc4cb29cb8cc-1200.jpg',
            'https://cdn.architextures.org/textures/20/11/ash-5fc4cb2f0d6d2-1200.jpg',
            'https://cdn.architextures.org/textures/20/11/charred-timber-5fc4cb0884792-1200.jpg'
        ]);

        // Função para exportar o mosaico como JSON
        document.getElementById('exportMap').addEventListener('click', function () {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(currentMosaic, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "mosaic_map.json");
            document.body.appendChild(downloadAnchorNode); // Requerido para o Firefox
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        });

        // Função para importar um mapa de mosaico a partir de um JSON
        document.getElementById('importMap').addEventListener('change', function (event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const jsonData = JSON.parse(e.target.result);
                    importMosaic(jsonData);
                };
                reader.readAsText(file);
            }
        });

        document.getElementById('generateTable').addEventListener('click', generateBlockTable);



        // Função para importar e criar a cena a partir de um mapa (JSON)
        function importMosaic(mosaicMap) {
            currentMosaic = mosaicMap; // Atualiza o mosaico atual com o importado

            // Limpar a cena
            while (scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }

            const cubeWidth = 1;
            const cubeDepth = 1;
            const gap = 0.01;

            // Adicionar cubos a partir do mapa importado
            mosaicMap.forEach(cubeData => {
                const myCube = cube(cubeWidth, cubeData.height, cubeDepth, cubeData.texture);
                myCube.position.set(cubeData.col * (cubeWidth + gap), cubeData.height / 2, cubeData.row * (cubeDepth + gap));
                scene.add(myCube);
            });

            // Reposicionar a câmera
            camera.position.set(3, 4, 10);
            camera.lookAt(0, 0, 0);
        }


    </script>

    <!-- Modal para exibir a tabela -->
    <div id="myModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Tabela de Materiais</h2>
            <div id="blockTable"></div> <!-- A tabela de materiais será gerada aqui -->

            <h2>Tabela do Mosaico</h2>
            <div id="mosaicTable"></div> <!-- A tabela do mosaico será gerada aqui -->
        </div>
    </div>

    <script>


        // Controle do modal
        // Controle do modal
        const modal = document.getElementById('myModal');
        const btn = document.getElementById('generateTable');
        const span = document.getElementsByClassName('close')[0];

        // Quando o usuário clica no botão, abre o modal
        btn.onclick = function () {
            generateBlockTable();  // Gera a tabela de materiais
            generateMosaicTable(10, 30); // Substitua pelos valores corretos de rows e cols do mosaico
            modal.style.display = 'block';  // Exibe o modal
        }

        // Quando o usuário clica no "X", fecha o modal
        span.onclick = function () {
            modal.style.display = 'none';
        }

        // Quando o usuário clica fora do modal, fecha o modal
        window.onclick = function (event) {
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        }

    </script>
</body>

</html>